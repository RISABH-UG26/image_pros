/*
 * Image Processing Accelerator - Bare-Metal Software
 * MicroBlaze Control Application
 * 
 * This software controls the image processing hardware accelerator.
 * No Linux required - runs directly on MicroBlaze.
 */

#include <stdio.h>
#include <stdint.h>
#include "xparameters.h"
#include "xil_io.h"
#include "xil_printf.h"

// ============================================
// Hardware Address Definitions
// ============================================
// Update these based on your Vivado address map
#define IMG_PROC_BASE_ADDR      XPAR_IMAGE_PROCESSING_0_S_AXI_CONTROL_BASEADDR
#define GPIO_BASE_ADDR          XPAR_AXI_GPIO_0_BASEADDR
#define IMAGE_BRAM_BASE_ADDR    XPAR_AXI_BRAM_CTRL_0_S_AXI_BASEADDR

// ============================================
// Image Processing IP Register Offsets
// (Generated by Vitis HLS)
// ============================================
#define CTRL_REG_OFFSET         0x00    // Control register
#define GIE_REG_OFFSET          0x04    // Global interrupt enable
#define IP_IER_OFFSET           0x08    // IP interrupt enable
#define IP_ISR_OFFSET           0x0C    // IP interrupt status
#define FILTER_SELECT_OFFSET    0x10    // Filter selection
#define THRESHOLD_VAL_OFFSET    0x18    // Threshold value
#define WIDTH_OFFSET            0x20    // Image width
#define HEIGHT_OFFSET           0x28    // Image height

// Control register bits
#define CTRL_START_BIT          0x01
#define CTRL_DONE_BIT           0x02
#define CTRL_IDLE_BIT           0x04
#define CTRL_READY_BIT          0x08

// ============================================
// Filter Mode Definitions
// ============================================
#define FILTER_BYPASS       0
#define FILTER_GRAYSCALE    1
#define FILTER_SOBEL        2
#define FILTER_THRESHOLD    3
#define FILTER_GAUSSIAN     4
#define FILTER_NEGATIVE     5
#define FILTER_SHARPEN      6

// ============================================
// Image Parameters
// ============================================
#define IMG_WIDTH   64
#define IMG_HEIGHT  64
#define IMG_SIZE    (IMG_WIDTH * IMG_HEIGHT)

// ============================================
// Test Image Data (64x64 grayscale)
// ============================================
static uint8_t test_image[IMG_SIZE];
static uint8_t output_image[IMG_SIZE];

// ============================================
// Generate Test Pattern
// ============================================
void generate_test_pattern(void) {
    xil_printf("Generating test pattern...\n\r");
    
    for (int y = 0; y < IMG_HEIGHT; y++) {
        for (int x = 0; x < IMG_WIDTH; x++) {
            int idx = y * IMG_WIDTH + x;
            
            // Create pattern with edges
            if ((x >= 20 && x < 44) && (y >= 20 && y < 44)) {
                test_image[idx] = 200;  // White square
            } else if ((x >= 16 && x < 48) && (y >= 16 && y < 48)) {
                test_image[idx] = 128;  // Gray border
            } else {
                test_image[idx] = (x + y) % 64;  // Gradient background
            }
        }
    }
}

// ============================================
// Load Image to BRAM
// ============================================
void load_image_to_bram(uint8_t* image, uint32_t size) {
    xil_printf("Loading image to BRAM...\n\r");
    
    for (uint32_t i = 0; i < size; i++) {
        Xil_Out8(IMAGE_BRAM_BASE_ADDR + i, image[i]);
    }
}

// ============================================
// Read Image from BRAM
// ============================================
void read_image_from_bram(uint8_t* image, uint32_t size) {
    xil_printf("Reading image from BRAM...\n\r");
    
    for (uint32_t i = 0; i < size; i++) {
        image[i] = Xil_In8(IMAGE_BRAM_BASE_ADDR + i);
    }
}

// ============================================
// Configure Image Processing IP
// ============================================
void configure_ip(uint8_t filter_mode, uint8_t threshold, 
                  uint16_t width, uint16_t height) {
    
    xil_printf("Configuring IP: filter=%d, threshold=%d, size=%dx%d\n\r",
               filter_mode, threshold, width, height);
    
    // Set filter parameters
    Xil_Out32(IMG_PROC_BASE_ADDR + FILTER_SELECT_OFFSET, filter_mode);
    Xil_Out32(IMG_PROC_BASE_ADDR + THRESHOLD_VAL_OFFSET, threshold);
    Xil_Out32(IMG_PROC_BASE_ADDR + WIDTH_OFFSET, width);
    Xil_Out32(IMG_PROC_BASE_ADDR + HEIGHT_OFFSET, height);
}

// ============================================
// Start Processing and Wait for Completion
// ============================================
void start_processing(void) {
    uint32_t status;
    
    xil_printf("Starting image processing...\n\r");
    
    // Start the IP
    Xil_Out32(IMG_PROC_BASE_ADDR + CTRL_REG_OFFSET, CTRL_START_BIT);
    
    // Wait for completion
    do {
        status = Xil_In32(IMG_PROC_BASE_ADDR + CTRL_REG_OFFSET);
    } while (!(status & CTRL_DONE_BIT));
    
    xil_printf("Processing complete!\n\r");
}

// ============================================
// Check IP Status
// ============================================
void check_ip_status(void) {
    uint32_t status = Xil_In32(IMG_PROC_BASE_ADDR + CTRL_REG_OFFSET);
    
    xil_printf("IP Status: ");
    if (status & CTRL_IDLE_BIT) xil_printf("IDLE ");
    if (status & CTRL_READY_BIT) xil_printf("READY ");
    if (status & CTRL_DONE_BIT) xil_printf("DONE ");
    xil_printf("\n\r");
}

// ============================================
// Print Image Statistics
// ============================================
void print_image_stats(uint8_t* image, uint32_t size, const char* name) {
    uint8_t min_val = 255;
    uint8_t max_val = 0;
    uint32_t sum = 0;
    
    for (uint32_t i = 0; i < size; i++) {
        if (image[i] < min_val) min_val = image[i];
        if (image[i] > max_val) max_val = image[i];
        sum += image[i];
    }
    
    xil_printf("%s - Min: %d, Max: %d, Avg: %d\n\r", 
               name, min_val, max_val, (uint32_t)(sum / size));
}

// ============================================
// Print Image (small preview)
// ============================================
void print_image_preview(uint8_t* image, int width, int height) {
    xil_printf("Image Preview (8x8 corner):\n\r");
    
    int preview_size = 8;
    for (int y = 0; y < preview_size && y < height; y++) {
        for (int x = 0; x < preview_size && x < width; x++) {
            xil_printf("%3d ", image[y * width + x]);
        }
        xil_printf("\n\r");
    }
}

// ============================================
// Run Filter Test
// ============================================
void run_filter_test(uint8_t filter_mode, const char* filter_name, uint8_t threshold) {
    xil_printf("\n\r========================================\n\r");
    xil_printf("Testing: %s\n\r", filter_name);
    xil_printf("========================================\n\r");
    
    // Load input image
    load_image_to_bram(test_image, IMG_SIZE);
    
    // Configure IP
    configure_ip(filter_mode, threshold, IMG_WIDTH, IMG_HEIGHT);
    
    // Check status
    check_ip_status();
    
    // Start processing
    start_processing();
    
    // Read output
    read_image_from_bram(output_image, IMG_SIZE);
    
    // Print statistics
    print_image_stats(output_image, IMG_SIZE, "Output");
    
    // Print preview
    print_image_preview(output_image, IMG_WIDTH, IMG_HEIGHT);
}

// ============================================
// Main Function
// ============================================
int main(void) {
    xil_printf("\n\r");
    xil_printf("========================================\n\r");
    xil_printf(" Image Processing Accelerator Demo\n\r");
    xil_printf(" Bare-Metal MicroBlaze Application\n\r");
    xil_printf("========================================\n\r");
    xil_printf("Image Size: %d x %d\n\r", IMG_WIDTH, IMG_HEIGHT);
    
    // Generate test pattern
    generate_test_pattern();
    print_image_stats(test_image, IMG_SIZE, "Input");
    print_image_preview(test_image, IMG_WIDTH, IMG_HEIGHT);
    
    // Test all filters
    run_filter_test(FILTER_BYPASS, "BYPASS", 128);
    run_filter_test(FILTER_SOBEL, "SOBEL EDGE DETECTION", 128);
    run_filter_test(FILTER_THRESHOLD, "THRESHOLD", 100);
    run_filter_test(FILTER_GAUSSIAN, "GAUSSIAN BLUR", 128);
    run_filter_test(FILTER_NEGATIVE, "NEGATIVE", 128);
    run_filter_test(FILTER_SHARPEN, "SHARPEN", 128);
    
    xil_printf("\n\r========================================\n\r");
    xil_printf(" All Tests Complete!\n\r");
    xil_printf("========================================\n\r");
    
    return 0;
}
